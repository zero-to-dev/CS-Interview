# 운영체제 개념 정리

## 프로세스와 쓰레드

### ✅ 프로세스

- 정의 : 프로그램을 메모리에 올린 동적인 상태로 프로그램이 실행될 때 프로세스 인스턴스가 생성된다고 표현
  - **OS가 프로그램을 메모리에 올리고 CPU를 위한 PCB(Process control block)을 할당한 상태**
- 프로그램 입장 : 프로그램 + PCB
- 스케줄러 입장 : task

### ✅ 쓰레드

- 정의 : CPU에서 처리하는 실행 하나가 스레드
  - 작업 처리 위해 수행하는 **실행** 단위
- CPU는 프로세스로부터 전달받은 스레드 수행
- OS 입장
  - 작업 = 프로세스
  - CPU의 작업 = 프로세스 내의 스레드

### ✅ 프로세스와 쓰레드와의 차이

1. 동시 작업, 시스템 자원을 멀티 스레드가 더 적게 사용
2. 프로세스 간 통신은 스레드 보다 복잡
3. 스레드의 동기화 이슈

- 프로세스 : 메모리에 올라갈 때 운영체제로부터 시스템 자원을 할당 받음

  - 운영체제는 프로세스마다 독립된 메모리 영역을 Code/Data/Stack/Heap 형식을 할당

- 스레드 : 프로세스가 할당받은 메모리 영역 내의 Stack 형식으로 할당된 메모리 영역은 따로 할당받고, 나머지는 code/data/heap 형식으로 할당된 메모리 영역 공유

#### 프로세스와 쓰레드의 작동 방식

- 프로세스 : 독립된 메모리 영역을 할당해 줌 -> 프로세스는 다른 프로세스의 변수나 자료에 접근 x

- 스레드 : 별도의 스택을 가지고 있지만 힙 메모리는 서로 읽고 쓸 수 있음

- 프로세스 실행 중 오류 발생 -> 강제 종료 시 다른 프로세스에게 어떤 영향?
  - 공유하고 있던 파일을 손상시키는 경우가 아니면 영향 X
- 스레드의 경우 메모리 영역의 내용 공유 -> 오류 발생 시 => 다른 스레드도 강제 종료

### 왜 이런 방식으로 메모리 공유?

- 운영체제에게 프로세스는 최소 작업 단위
- 프로세스는 하나 이상의 스레드 보유
- 프로세스가 최소 작업 단위 -> 동일 프로세스 소속의 스레드끼리 메모리를 공유함

### ✅ 기출문제

- Q. 프로세스와 쓰레드의 차이?
  - 프로세스는 독립된 메모리가 할당됨
  - 쓰레드는 별도의 스택이 주어지지만 나머지 힙 메모리는 공유됨
- Q. 프로세스의 문제점
  - 프로세스 생성 시 큰 오버헤드
  - 컨텍스트 스위칭의 비효율성
  - 프로세스 간의 통신이 어려운점
- Q. 쓰레드의 출현 목적
  - 1. 프로세스보다 크기가 작은 실행 단위 필요
  - 2. 빠른 컨텍스트 스위칭
  - 3. 프로세스의 생성 및 소멸에 따른 오버헤드 감소
  - 4. 프로세스들의 통신 시간, 방법 어려움 해소
  - 자원 효율성과 작업 유연성
  - 1. 응답성 향상 : 다른 스레드들이 작업 계속 응답 가능
  - 2. 자원의 공유 : 불필요한 자원 중복 막아짐
  - 3. 다중 CPU 지원 시 멀티 스레드로 처리 가능
- Q. 쓰레드의 주소공간에 대한 설명
  - 쓰레드 동작을 위한 총 6개의 공간
    - 사적 공간
      - 스레드 코드 영역 : 스레드가 실행할 작업의 함수가 있으며 스레드는 프로세스 코드 영역에 있느 ㄴ다른 모든 함수를 호출 할 수 있음
      - 스레드 로컬 스토리지
      - 스레드 사용자 스택 : 프로세스 스택의 일부분을 할당
    - 공유 공간
      - 프로세스에 선언된 함수 코드
      - 데이터 : 개별 스레드 전용 공간인 스레드 로컬 스토리지와 프로세스에 의해 공유되는 변수 공간
      - 힙 : 모든 스레드가 동적 할당을 받는 공간으로 프로세스이 힙 공간 사용
    - 커널 스택
- Q. 멀티 태스킹과 멀티 스레드
  - 멀티 태스킹
    - 하나의 운영체제 안에 여러 프로세스가 실행
  - 멀티 스레드
    - 하나의 프로세스가 여러 스레드를 사용하여 동시 처리
    - 장점
      - 1. context switching 할 때 공유하고 있는 메모리 만큼의 메모리 자원을 아낄 수 있음
      - 2. 스레드는 프로세스 내의 stack 영역을 제외한 모든 메모리 공유 -> 통신의 부담이 적어 응답 시간이 빠름
    - 단점
      - 1. 스레드가 프로세스 자원 망칠 시, 모든 프로세스 종류
      - 2. 자원 공유로 동기화 문제 발생
    - 동기화 문제
      - 전역 변수를 사용할 경우 발생할 수 있는 충돌
      - 프로그래머가 직접 동기화 문제를 대응해야 함
- Q. 다른 프로세스 접근 방법
  - 1. IPC
  - 2. LPC
  - 3. 별도 공유 메모리 생성 및 정보 공유

## 페이징과 세그멘테이션

### ✅ 페이징의 정의

- 세그멘테이션과 가상 메모리를 고정된 크기로 나누고 메모리를 관리하는 것

### ✅ 세그멘테이션의 정의

- 메모리를 서로 크기가 다른 논리적인 블록 단위인 세그먼트로 분할 -> 메모리 할당 및 물리 주소를 논리 주소로 변환하는 거

### ✅ 페이징과 세그멘테이션의 공통점

- 프로그램을 실행하기 위해 디스크의 내용을 분할 및 메모리에 적재하는 불연속 메모리 관리 기법

### ✅ 페이징과 세그멘테이션의 차이점

- 프로그램을 분할하는 방식
- 1. 페이지는 고정 블록 크기, 세그먼트는 가변 크기
- 2. 페이징은 고정 블록 크기 -> 내부 단편화, 메모리가 가변 크기 블록으로 적재되어 세그멘테이션에서는 외부 조각이 발생할 수 있음
- 3. 페이지의 크기는 하드웨어에 의해 결정, 세그먼트는 사용자가 지정
- 4. 페이징의 페이지 테이블은 논리 주소를 실제 주소에 매핑 , 세그먼트에서는 세그먼트 테이블이 논리 주소를 실제 주소로 매핑
- 5. 페이징에서 페이지 번호와 오프셋으로 나뉜 주소로만 하나의 정수 제공, 세그먼트에서는 세그먼트의 수와 오프셋의 두 개의 수로 주소 지정

### ✅ 기출문제

**Q. 메모리 단편화란?**

- 메모리의 공간을 여러 개로 나뉘어 사용할 때, 충분히 사용 가능한 메모리가 있음에도 불구하고 할당을 못하는 상태

**Q. 외부 단편화와 내부 단편화란?**

- 외부 단편화
  - 메모리 할당/해제 작업 시 사용 가능한 공간이 존재하여 전체적으로 사용 가능한 메모리의 양은 충분하나 실제로 메모리를 할당할 수 없는 상태
- 내부 단편화
  - 메모리 할당하는 최소 블록의 크기에 비해 작업에 필요한 메모리의 양이 작은 경우, 남은 공간이 생겨 메모리 낭비하게 되는 상황

**Q. 외부 단편화를 해결하는 페이징 기법에 대한 설명**

- 프레임 : 램을 일정한 크기의 블록으로 나눈 것
- 페이징 : 논리 메모리 또는 가상 메모리를 일정 크기의 블록으로 나눈 것

- 페이징 기법 : 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법
  - page mapping에 사용을 위한 page table을 생성
  - 연속적이지 않던 공간을 연속적으로 활용 가능
  - mapping이 늘어나는 단점 발생

**Q. 내부 단편화를 해결하는 세그멘테이션 기법 설명**

- 가상 메모리를 서로 크기가 다른 세그먼트를 논리적 단위로 분할 및 사용하는 기법
- 세그먼트 테이블 : 세그먼트 번호, 시작 주소, 세그먼트 크기
- 1. CPU가 세그먼트 테이블에게 테이블 번호, 메모리 크기 전달
- 2. 세그먼트 테이블은 메모리로 가 해당 테이블의 번호 base와 limit를 비교
- 3. limit보다 메모리 공간이 작으면 인터럽트 발생
- 4. 강제 종료
- 세그멘테이션 기법은 크기가 다양한 만큼 메모리 낭비 존재 -> 페이징 기법을 더 많이 사용

## 뮤텍스와 세마포어

### ✅ 뮤텍스의 정의

- 상호배제, 임계 영역을 가진 쓰레드들의 Running Time이 서로 겹치지 않게 각각 단독으로 실행하게 하는 기술
- 다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 locking과 unlocking 사용
- 뮤텍스 객체를 두 쓰레드가 동시 사용 x

#### 뮤텍스 코드

- 공유 자원 점유한 프로세스가 락 보유
- 자원 사용 마치면 락 반납

```c
mutex = 1;

void lock () {
	while (mutex != 1)
  {
    // mutex 값이 1이 될 때까지 대기
  }
    // 이 구역에 도착했다는 것은 화장실 키를 획득 했다는 것이고 mutex 값이 1이라는 뜻. 이제 뮤텍스 값을 0으로 만들어 다른 프로세스(혹은 쓰레드)의 접근을 제한.
   mutex = 0;
}

void unlock() {
	// 임계 구역(화장실)에서 나온 프로세스는 다른 프로세스가 접근할 개수 있도록 뮤텍스 값을 1으로 만들어 락을 해제.
	mutex = 1;
}
```

_출처: https://rebas.kr/857 [PROJECT REBAS:티스토리]_

### ✅ 세마포어의 정의

- 리소스의 상태를 나타내는 간단한 카운터
- 특정 프로세스가 공유 자원 사용중 -> 다른 프로세스가 공유 자원을 사용하지 못하도록 함
- P 연산 : wait/ 자원을 사용하려는 프로세스들의 진입 엽무를 자원 카운트(S)를 통해 결정, 카운트를 감소 시켜, 자원 점유 알림
- V 연산 : Signal 동작/ 대기 중인 프로세스를 깨우는 신호, 카운트 증가(S++) 자원 반납을 알림

#### 세마포어 코드

-

```C
struct semaphore {
	int count;
    	queueType queue;
};

void semWait (semaphore s) {
	s.count--;
    if (s.count < 0)
    {
    	// 이 구역으로 들어왔다는 것은 현재 프로세스(스레드)가 공유 자원에 접근할 수 없다는 것을 의미.
    	// 요청한 프로세스를 s.queue에 연결
      // 요청한 프로세스를 블록 상태로 락
    }
}

void semSignal (semaphore s) {
	s.count++;
    if (s.count <= 0)
    {
    	// 대기하고 있는 프로세스(스레드)를 위해 s.queue에 연결되어 있는 프로세스를 큐에서 제거
      // 프로세스의 상태를 실행 가능으로 변경하고 ready list에 연결
    }
}
```

```C
const int n = // 프로세스 개수
semaphore s = 1;

void Process (int i) {
	while (true)
  {
     semWait(s); //세마포어 값을 감소시킨다.

     /* 임계 영역(Critical Section) */

     semSignal(s); //세마포어 값을 증가시킨다.

     /* 임계 영역 이후 코드 */
   }
}

void main() {
	parbegin (Process(1), Process(2), ..., Process(n));
}
```

_출처:[세마포어와 뮤텍스의 차이](https://velog.io/@hidaehyunlee/Philosophers-%EC%98%88%EC%8B%9C%EC%98%88%EC%A0%9C%EB%A1%9C-%EB%B3%B4%EB%8A%94-%EB%AE%A4%ED%85%8D%EC%8A%A4%EC%99%80-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%9D%98-%EC%B0%A8%EC%9D%B4)_

### ✅ 뮤텍스와 세마포어의 공통점

- 여러 개의 프로세스가 동시 접근하면서 문제 발생 -> 안전하게 관리하기 위해 상호배제를 달성하는 기법
- 세마포어와 뮤텍스 = 상호배제 달성을 위한 기법

### ✅ 뮤텍스와 세마포어의 차이점

1. 세마포어는 뮤텍스가 될 수 있으나 뮤텍스는 세마포어가 될 수 없음
2. 세마포어는 소유 x, 뮤텍스는 소유 가능
3. 뮤텍스를 소유하고 있는 쓰레드가 뮤텍스 해제 가능, 세마포어의 경우 세마포어를 소유하지 않는 쓰레드가 세마포어 해제 가능
4. 세마포어는 시스템 범위에 걸쳐있고 파일 형태로 존재, 뮤텍스는 프로세스 범위이며 프로세스 종료될 때 자동으로 clean up

**가장 큰 차이: 동기화 대상의 개수**

- 뮤텍스 : 동기화 대상이 오직 하나
- 세마포어: 동기화 대상이 하나 이상

### ✅ 기출문제

Q. 뮤텍스와 세마포어 차이

- 동기화 대상의 개수에 따라 차이가 나며 동기화 대상이 하나이면 뮤텍스, 동기화 대상이 하나 이상이면 세마포어이다

## 프로세스간 통신의 방법

### ✅ IPC 란

- IPC(Inter Process Communication): 프로세스 간 의사소통하는 것
  - 프로세스간 통신 = 다른 프로세스가 데이터를 주고받을 수 있음 + 프로세스들이 공유하는 메모리 필요하다는 뜻
- 인터넷 통신은 IPC의 확장
- 커널 영역에서 제공

### ✅ 프로세스 통신이 어려운 이유

- 프로세스는 별도의 자원을 할당하며 통신할 수 있는 공간이 없어 통신을 위한 별도 공간을 만들어줘야 해서 통신이 스레드보다 어려움

### ✅ 프로세스간 통신의 종류

#### 공유 메모리

- 프로세스 간 메모리 영역을 공유해서 사용할 수 있도록 함
- 프로세스가 공유 메모리 할당을 커널 요청 -> 커널은 해당 프로세스에 메모리 공간 할당
  - 공유 메모리가 프로세스에 첨부하는 방식으로 작동
  - 프로세스가 메모리 영역에 첨부
- 대량의 정보를 다수의 프로세스에 배포 가능
- 중개자 없이 곧바로 메모리 접근 가능, 모든 IPC 중 가장 빠르게 작동 가능

#### 파이프

- 통신 위한 메모리 공간을 생성 -> 데이터를 주고 받음
- 1. 익명 파이프
  - 통신할 프로세스가 명확하게 알 수 있는 경우에 사용
    - 외부 프로세스에서 사용x, 부모-자식 or 형제 프로세스 간 통신 사용
  - 파이프 : 두 프로세스 연결, 하나의 프로세스 read만 다른 하나는 write만 함
    - 반이중 통신 : 한 쪽 방향으로만 통신 가능한 특성
  - 간단하게 사용 가능
  - 단점
    - 반이중 통신 : pipe 두 개를 만들어야 하는 경우 구현이 복잡할 수 있음
    - 전이중 통신 시 낭비가 심해짐
- 2. 네임드 파이프
  - 모르는 상태의 프로세스들 사이의 통신에 이용
  - 익명 파이프의 확장, 부모 프로세스와 무관한 다른 프로세스도 통신 가능
    - 통신을 위해 이름이 있는 파일을 사용
    - FIFO라는 특수 파일을 이용해 관련없는 프로세스 간 통신 가능
  - 단점
    - 반이중 통신 : 익명 파이프 처럼 2개 만들어야 함

#### 소켓

- UNIX 도메인 소켓 또는 IPC 소켓은 동일한 호스트 운영체제에서 실행되는 프로세스간 데이터 교환을 위한 데이터 통신 엔드 포이트
- 네트워크 소켓 통신을 통해 데이터 공유
  - 데이터 교환을 위해 양쪽 PC에 각각 임의의 포트 정하고 해당 포트 간의 대화를 통해 데이터를 주고받는 방식
- 클라이언트와 서버가 소켓을 통해 통신하는 구조, 원격에서 프로세스 간 데이터 공유
- 전이중 통신 가능
- 서버/클라이언트 환경 구축 시 용이

#### 메시지큐

- 입출력 방식은 Named 파이프 동일
- 차이점
  - 데이터 흐름이 아닌 메모리 공간
  - 다수의 프로세스간 메시지를 전달 가능
- 메시지 접근을 위한 키 필요
- 사용할 데이터에 번호 붙여 여러 프로세스가 동시에 데이터를 다룰 수 있음

#### 메모리 맵

- 공유 메모리처럼 메모리 공유
- 열린 파일을 메모리에 맵핑시켜 공유하는 방식
- 대용량 데이터를 공유해야 할 때 사용
- 메모리 맵 파일은 크기를 바꿀 수 없으며 사용 이전 또는 이후에만 파일 크기를 변경할 수 있음

#### RPC(remote procedure call)

- 분산 네트워크 망에서 많이 사용되는 방식
- 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게하는 프로세스 간 통신 기술
- 분리된 PC에 저장된 데이터를 마치 자기 PC에 존재하는 것처럼 데이터를 가져와 사용하는 통신

**IPC 통신은 데이터 동기화 및 보호를 위해 세마포어 및 뮤텍스 사용**

#### 요약

| IPC 종류     | PIPE                       | Named PIPE                     | Message Queue                  | Shared memory                  | Memory Map                     | Socket                         |
| ------------ | -------------------------- | ------------------------------ | ------------------------------ | ------------------------------ | ------------------------------ | ------------------------------ |
| 사용시기     | 부모 자식간 단 방향 통신시 | 다른 프로세스와 단 방향 통신시 | 다른 프로세스와 단 방향 통신시 | 다른 프로세스와 양 방향 통신시 | 다른 프로세스와 양 방향 통신시 | 다른 프로세스와 양 방향 통신시 |
| 공유매개체   | 파일                       | 파일                           | 메모리                         | 메모리                         | 파일+메모리                    | 소켓                           |
| 통신단위     | Stream                     | Stream                         | 구조체                         | 구조체                         | 페이지                         | Stream                         |
| 통신방향     | 단방향                     | 단방향                         | 단방향                         | 양방향                         | 양방향                         | 양방향                         |
| 통신가능범위 | 동일시스템                 | 동일시스템                     | 동일시스템                     | 동일시스템                     | 동일시스템                     | 동일+외부시스템                |

### ✅ 기출문제

- Q. IPC의 정의와 종류
  - 코드를 제외한 메모리공간에 공유되지 않아 프로세스가 다른 프로세스의 메모리접근 불가 -> 서로 다른 프로세스가 통신할 수 있도록 운영체제 커널이 지원하는 것이 IPC
  - 대표적으로 공유메모리, 파이프
- Q. IPC의 예시
  - 크게 2가지 모델로 나뉨
    - 1. 공유 메모리 : 주소 공간의 일부 공유, 공유한 메모리 영역에서 읽기/쓰기 통해 공유하는 모델
    - 2. 메세지 전송 모델 : 커널 메모리 영역에 메시지 전달을 위한 채널 만들고 송수신자간에 전송/수신 통해 통신
- Q. 두 모델의 장단점
  - 공유 메모리 모델 : 커널 관여 x, 직접 사용하고 통신하여 통신 속도가 빠름
    - 단점 : 별도 동기화 과정이 필요, 동시에 메모리 위치에 접근하는 문제가 발생 가능
  - 메세지 전달 모델 : 커널을 통해 데이터 주고 받아서 통신 속도가 느림
    - 커널에서 데이터를 주고 받는 과정을 컨트롤하여 안전, 커널이 동기화 제공

## 데드락 발생 조건과 대응법

### ✅ 데드락 정의

- 둘 이상의 프로세스가 다른 프로세스가 점유하는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황

### ✅ 데드락 발생 조건

- 상호배제 : 한 번에 프로세스 하나만 해당 자원 사용 가능
- 점유대기 : 자원을 최소한 하나 보유, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스 존재
- 비선점 : 할당된 자원을 강제로 뺏을 수 없음
- 순환대기 : 대기 프로세의 집합이 순환 형태로 자원 대기

### ✅ 데드락 발생 대응법

- 예방
- 회피
- 탐지 및 회복

#### 회복

- 발생조건을 하나라도 발생하지 않도록 하는 것
  - 자원의 상호배제 조건 방지 : 한번에 여러 프로세스가 공유 자원을 사용할 수 있도록 함
  - 점유 대기 조건 방지 : 프로세스 실행에 필요한 모든 자원을 한꺼번에 요규 허용할 때까지 작업 보류, 대기 조건이 성립되지 않도록 함
  - 비선점 조건 방지 : 할당된 자원이 선점권이 없다고 가정, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 함
  - 순환 대기 조건 방지 : 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만 자원요구할 수 있도록 함
- 단점 : 시스템의 처리량이나 효율성을 떨어뜨림

#### 회피

- safe state : 프로세스가 요청하는 자원을 모두에게 할당해줄 수 있는 상태
- safe sequence : 데드락이 발생하지 않는 순서를 찾을 수 있음
- safe state의 반대 의미, 교착 상태가 불안정 상태의 부분집합
- 회피 알고리즘 : 자원을 할당한 후, 시스템이 항상 safe state에 있을 수 있도록 할당을 허용하는 것

#### 데드락 탐지 및 회복

- 탐지 : 데드락 발생 여부 탐색, 자원 할당 그래프를 이용하여 탐지
- 회복 : 탐지 기법을 통해 발견 후, 순환대기에 벗어나 데드락으로부터 회복하기 위한 방법 사용
  - 1. 단순히 프로세스 1개 이상 중단시키기
    - 교착 상태에 빠진 모든 프로세스 중단 : 부분 결과가 폐기될 수 있는 부작용
    - 프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락 탐지 하면서 회복 시키는 방법 : 탐지 알고리즘 호출 및 수행으로 부담
  - 2. 자원 선점
    - 교착 상태가 해결될 때까지 자원을 다른 프로세스에 할당해주는 방법

### ✅ 기출 문제

- Q. 데드락의 정의
  - 프로세스가 자원을 얻지 못해 다음 처리를 못하는 상태
- Q. 데드락의 조건
  - 상호배제
  - 점유대기
  - 비선점
  - 순환대기
- Q. 데드락 처리
  - 교착상태 예방 및 회피
  - 교착상태 탐지 및 회복
  - 교착 상태 무시
